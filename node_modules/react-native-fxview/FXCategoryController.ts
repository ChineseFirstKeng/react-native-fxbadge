import React from "react";
import { FXComponentItem, FXComponentController } from "./types";
import { HeapType, PriorityOrder, PriorityQueue } from "./queue/PriorityQueue";
import logger from "./logger/FXLogger";

export class FXCategoryController {
  public fxViewId: string;
  public categoryId: string;
  private updateCallback?: () => void;

  // 存储组件的 Map 和优先队列
  private componentMap: Map<string, FXComponentItem> = new Map();
  private componentQueue: PriorityQueue<FXComponentItem> = new PriorityQueue(
    HeapType.MAX_HEAP,
    PriorityOrder.FIFO,
  );

  constructor(
    fxViewId: string,
    categoryId: string,
    triggerUpdate?: () => void,
  ) {
    this.fxViewId = fxViewId;
    this.categoryId = categoryId;
    this.updateCallback = triggerUpdate;
  }

  // ========== 主要 API 方法 ==========

  /**
   * 创建并展示组件
   * @param component 要显示的组件
   * @param componentId 可选的组件 ID
   * @returns 组件控制器
   */
  add(component: React.ReactNode, componentId?: string): FXComponentController {
    logger.info(
      `FXViewCategoryController.add`,
      `[${this.categoryId}]`,
      componentId,
    );

    const finalComponentId = componentId || this.autoComponentId();

    // 如果组件已存在，先移除旧的
    if (this.componentMap.has(finalComponentId)) {
      logger.warn(
        `Component ${finalComponentId} already exists, removing old one`,
      );
      this.remove(finalComponentId);
    }

    const componentItem: FXComponentItem = {
      componentId: finalComponentId,
      component,
      visible: true, // add 方法默认可见
    };

    this.componentMap.set(finalComponentId, componentItem);
    this.componentQueue.enqueue(componentItem);
    this.triggerUpdate();

    return this.createController(finalComponentId);
  }

  /**
   * 创建但不显示组件
   * @param component 要创建的组件
   * @param componentId 可选的组件 ID
   * @returns 组件控制器
   */
  build(
    component: React.ReactNode,
    componentId?: string,
  ): FXComponentController {
    logger.info(
      `FXViewCategoryController.build`,
      `[${this.categoryId}]`,
      componentId,
    );

    const finalComponentId = componentId || this.autoComponentId();

    // 如果组件已存在，先移除旧的
    if (this.componentMap.has(finalComponentId)) {
      logger.warn(
        `Component ${finalComponentId} already exists, removing old one`,
      );
      this.remove(finalComponentId);
    }

    const componentItem: FXComponentItem = {
      componentId: finalComponentId,
      component,
      visible: false, // build 方法默认不可见
    };

    this.componentMap.set(finalComponentId, componentItem);
    this.componentQueue.enqueue(componentItem);

    // build 不触发更新，因为组件不可见
    // this.triggerUpdate();

    return this.createController(finalComponentId);
  }

  /**
   * 显示已存在的组件
   * @param componentId 组件 ID
   */
  show(componentId: string): void {
    logger.info(
      `FXViewCategoryController.show`,
      `[${this.categoryId}]`,
      componentId,
    );

    const componentItem = this.componentMap.get(componentId);

    if (!componentItem) {
      logger.warn(
        `Component ${componentId} not found in category ${this.categoryId}`,
      );
      return;
    }

    // 如果已经可见，不需要重复操作
    if (componentItem.visible) {
      logger.info(`Component ${componentId} is already visible`);
      return;
    }

    componentItem.visible = true;
    this.triggerUpdate();
  }

  /**
   * 隐藏但不删除组件
   * @param componentId 组件 ID
   */
  hide(componentId: string): void {
    logger.info(
      `FXViewCategoryController.hide`,
      `[${this.categoryId}]`,
      componentId,
    );

    const componentItem = this.componentMap.get(componentId);

    if (!componentItem) {
      logger.warn(
        `Component ${componentId} not found in category ${this.categoryId}`,
      );
      return;
    }

    // 如果已经隐藏，不需要重复操作
    if (!componentItem.visible) {
      logger.info(`Component ${componentId} is already hidden`);
      return;
    }

    componentItem.visible = false;
    this.triggerUpdate();
  }

  /**
   * 更新组件内容
   * @param componentId 组件 ID
   * @param component 新的组件内容
   */
  update(componentId: string, component: React.ReactNode): void {
    logger.info(
      `FXViewCategoryController.update`,
      `[${this.categoryId}]`,
      componentId,
    );

    const componentItem = this.componentMap.get(componentId);

    if (!componentItem) {
      logger.warn(
        `Component ${componentId} not found in category ${this.categoryId}`,
      );
      return;
    }

    // 更新组件内容
    componentItem.component = component;

    // 只有在组件可见时才触发更新
    if (componentItem.visible) {
      this.triggerUpdate();
    } else {
      logger.info(
        `Component ${componentId} is hidden, update without re-render`,
      );
    }
  }

  /**
   * 彻底删除组件
   * @param componentId 组件 ID（必需）
   */
  remove(componentId: string): void {
    logger.info(
      `FXViewCategoryController.remove`,
      `[${this.categoryId}]`,
      componentId,
    );

    const componentItem = this.componentMap.get(componentId);

    if (!componentItem) {
      logger.warn(
        `Component ${componentId} not found in category ${this.categoryId}`,
      );
      return;
    }

    // 从 Map 中删除
    this.componentMap.delete(componentId);

    // 从优先队列中删除
    this.componentQueue.remove(componentItem);

    this.triggerUpdate();
  }

  /**
   * 移除最后一个组件（可选：用于向后兼容）
   */
  removeLast(): void {
    logger.info(`FXViewCategoryController.removeLast`, `[${this.categoryId}]`);

    const lastComponent = this.componentQueue.peek();

    if (!lastComponent) {
      logger.warn(`No component to remove in category ${this.categoryId}`);
      return;
    }

    this.remove(lastComponent.componentId);
  }

  /**
   * 清空所有组件
   */
  clearAll(): void {
    logger.info(`FXViewCategoryController.clearAll`, `[${this.categoryId}]`);

    const hadVisibleComponents = Array.from(this.componentMap.values()).some(
      (item) => item.visible,
    );

    this.componentMap.clear();
    this.componentQueue.clear();

    // 只有在有可见组件时才触发更新
    if (hadVisibleComponents) {
      this.triggerUpdate();
    }
  }

  /**
   * 注册更新回调
   * @param updateCallback 更新回调函数
   */
  registerUpdateCallback(updateCallback?: () => void): void {
    this.updateCallback = updateCallback;
  }

  /**
   * 获取组件列表
   * @returns 组件列表
   */
  getComponents(): FXComponentItem[] {
    return this.componentQueue.getAll();
  }

  /**
   * 获取组件数量
   * @returns 组件数量
   */
  getComponentCount(): number {
    return this.componentMap.size;
  }

  /**
   * 获取可见组件数量
   * @returns 可见组件数量
   */
  getVisibleComponentCount(): number {
    return Array.from(this.componentMap.values()).filter((item) => item.visible)
      .length;
  }

  /**
   * 检查组件是否存在
   * @param componentId 组件 ID
   * @returns 是否存在
   */
  hasComponent(componentId: string): boolean {
    return this.componentMap.has(componentId);
  }

  /**
   * 检查组件是否可见
   * @param componentId 组件 ID
   * @returns 是否可见
   */
  isVisible(componentId: string): boolean {
    const component = this.componentMap.get(componentId);
    return component?.visible ?? false;
  }

  // ========== 私有方法 ==========

  /**
   * 触发更新
   */
  private triggerUpdate(): void {
    logger.info(
      `FXViewCategoryController.triggerUpdate`,
      `[${this.categoryId}]`,
    );

    if (this.updateCallback) {
      this.updateCallback();
    }
  }

  /**
   * 创建组件控制器
   * @param componentId 组件 ID
   * @returns 组件控制器
   */
  private createController(componentId: string): FXComponentController {
    logger.info(
      `FXViewCategoryController.createController`,
      `[${this.categoryId}]`,
      componentId,
    );

    // ✅ 修复：不在闭包中捕获 componentItem，每次都从 Map 获取最新引用
    return {
      show: () => {
        this.show(componentId);
      },
      hide: () => {
        this.hide(componentId);
      },
      remove: () => {
        this.remove(componentId);
      },
      update: (component: React.ReactNode) => {
        this.update(componentId, component);
      },
      getFxViewId: () => this.fxViewId,
      getCategoryId: () => this.categoryId,
      getComponentId: () => componentId,
      getComponent: () => {
        // ✅ 每次都从 Map 获取最新的组件引用
        return this.componentMap.get(componentId)?.component;
      },
      isVisible: () => {
        return this.isVisible(componentId);
      },
      exists: () => {
        return this.hasComponent(componentId);
      },
    };
  }

  /**
   * 自动生成 componentId
   * @returns 生成的 componentId
   */
  private autoComponentId(): string {
    return `component_${Date.now()}_${Math.random()
      .toString(36)
      .substring(2, 9)}`;
  }
}
