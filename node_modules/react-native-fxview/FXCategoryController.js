"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FXCategoryController = void 0;
const PriorityQueue_1 = require("./queue/PriorityQueue");
const FXLogger_1 = __importDefault(require("./logger/FXLogger"));
class FXCategoryController {
    constructor(fxViewId, categoryId, triggerUpdate) {
        // 存储组件的 Map 和优先队列
        this.componentMap = new Map();
        this.componentQueue = new PriorityQueue_1.PriorityQueue(PriorityQueue_1.HeapType.MAX_HEAP, PriorityQueue_1.PriorityOrder.FIFO);
        this.fxViewId = fxViewId;
        this.categoryId = categoryId;
        this.updateCallback = triggerUpdate;
    }
    // ========== 主要 API 方法 ==========
    /**
     * 创建并展示组件
     * @param component 要显示的组件
     * @param componentId 可选的组件 ID
     * @returns 组件控制器
     */
    add(component, componentId) {
        FXLogger_1.default.info(`FXViewCategoryController.add`, `[${this.categoryId}]`, componentId);
        const finalComponentId = componentId || this.autoComponentId();
        // 如果组件已存在，先移除旧的
        if (this.componentMap.has(finalComponentId)) {
            FXLogger_1.default.warn(`Component ${finalComponentId} already exists, removing old one`);
            this.remove(finalComponentId);
        }
        const componentItem = {
            componentId: finalComponentId,
            component,
            visible: true, // add 方法默认可见
        };
        this.componentMap.set(finalComponentId, componentItem);
        this.componentQueue.enqueue(componentItem);
        this.triggerUpdate();
        return this.createController(finalComponentId);
    }
    /**
     * 创建但不显示组件
     * @param component 要创建的组件
     * @param componentId 可选的组件 ID
     * @returns 组件控制器
     */
    build(component, componentId) {
        FXLogger_1.default.info(`FXViewCategoryController.build`, `[${this.categoryId}]`, componentId);
        const finalComponentId = componentId || this.autoComponentId();
        // 如果组件已存在，先移除旧的
        if (this.componentMap.has(finalComponentId)) {
            FXLogger_1.default.warn(`Component ${finalComponentId} already exists, removing old one`);
            this.remove(finalComponentId);
        }
        const componentItem = {
            componentId: finalComponentId,
            component,
            visible: false, // build 方法默认不可见
        };
        this.componentMap.set(finalComponentId, componentItem);
        this.componentQueue.enqueue(componentItem);
        // build 不触发更新，因为组件不可见
        // this.triggerUpdate();
        return this.createController(finalComponentId);
    }
    /**
     * 显示已存在的组件
     * @param componentId 组件 ID
     */
    show(componentId) {
        FXLogger_1.default.info(`FXViewCategoryController.show`, `[${this.categoryId}]`, componentId);
        const componentItem = this.componentMap.get(componentId);
        if (!componentItem) {
            FXLogger_1.default.warn(`Component ${componentId} not found in category ${this.categoryId}`);
            return;
        }
        // 如果已经可见，不需要重复操作
        if (componentItem.visible) {
            FXLogger_1.default.info(`Component ${componentId} is already visible`);
            return;
        }
        componentItem.visible = true;
        this.triggerUpdate();
    }
    /**
     * 隐藏但不删除组件
     * @param componentId 组件 ID
     */
    hide(componentId) {
        FXLogger_1.default.info(`FXViewCategoryController.hide`, `[${this.categoryId}]`, componentId);
        const componentItem = this.componentMap.get(componentId);
        if (!componentItem) {
            FXLogger_1.default.warn(`Component ${componentId} not found in category ${this.categoryId}`);
            return;
        }
        // 如果已经隐藏，不需要重复操作
        if (!componentItem.visible) {
            FXLogger_1.default.info(`Component ${componentId} is already hidden`);
            return;
        }
        componentItem.visible = false;
        this.triggerUpdate();
    }
    /**
     * 更新组件内容
     * @param componentId 组件 ID
     * @param component 新的组件内容
     */
    update(componentId, component) {
        FXLogger_1.default.info(`FXViewCategoryController.update`, `[${this.categoryId}]`, componentId);
        const componentItem = this.componentMap.get(componentId);
        if (!componentItem) {
            FXLogger_1.default.warn(`Component ${componentId} not found in category ${this.categoryId}`);
            return;
        }
        // 更新组件内容
        componentItem.component = component;
        // 只有在组件可见时才触发更新
        if (componentItem.visible) {
            this.triggerUpdate();
        }
        else {
            FXLogger_1.default.info(`Component ${componentId} is hidden, update without re-render`);
        }
    }
    /**
     * 彻底删除组件
     * @param componentId 组件 ID（必需）
     */
    remove(componentId) {
        FXLogger_1.default.info(`FXViewCategoryController.remove`, `[${this.categoryId}]`, componentId);
        const componentItem = this.componentMap.get(componentId);
        if (!componentItem) {
            FXLogger_1.default.warn(`Component ${componentId} not found in category ${this.categoryId}`);
            return;
        }
        // 从 Map 中删除
        this.componentMap.delete(componentId);
        // 从优先队列中删除
        this.componentQueue.remove(componentItem);
        this.triggerUpdate();
    }
    /**
     * 移除最后一个组件（可选：用于向后兼容）
     */
    removeLast() {
        FXLogger_1.default.info(`FXViewCategoryController.removeLast`, `[${this.categoryId}]`);
        const lastComponent = this.componentQueue.peek();
        if (!lastComponent) {
            FXLogger_1.default.warn(`No component to remove in category ${this.categoryId}`);
            return;
        }
        this.remove(lastComponent.componentId);
    }
    /**
     * 清空所有组件
     */
    clearAll() {
        FXLogger_1.default.info(`FXViewCategoryController.clearAll`, `[${this.categoryId}]`);
        const hadVisibleComponents = Array.from(this.componentMap.values()).some((item) => item.visible);
        this.componentMap.clear();
        this.componentQueue.clear();
        // 只有在有可见组件时才触发更新
        if (hadVisibleComponents) {
            this.triggerUpdate();
        }
    }
    /**
     * 注册更新回调
     * @param updateCallback 更新回调函数
     */
    registerUpdateCallback(updateCallback) {
        this.updateCallback = updateCallback;
    }
    /**
     * 获取组件列表
     * @returns 组件列表
     */
    getComponents() {
        return this.componentQueue.getAll();
    }
    /**
     * 获取组件数量
     * @returns 组件数量
     */
    getComponentCount() {
        return this.componentMap.size;
    }
    /**
     * 获取可见组件数量
     * @returns 可见组件数量
     */
    getVisibleComponentCount() {
        return Array.from(this.componentMap.values()).filter((item) => item.visible)
            .length;
    }
    /**
     * 检查组件是否存在
     * @param componentId 组件 ID
     * @returns 是否存在
     */
    hasComponent(componentId) {
        return this.componentMap.has(componentId);
    }
    /**
     * 检查组件是否可见
     * @param componentId 组件 ID
     * @returns 是否可见
     */
    isVisible(componentId) {
        var _a;
        const component = this.componentMap.get(componentId);
        return (_a = component === null || component === void 0 ? void 0 : component.visible) !== null && _a !== void 0 ? _a : false;
    }
    // ========== 私有方法 ==========
    /**
     * 触发更新
     */
    triggerUpdate() {
        FXLogger_1.default.info(`FXViewCategoryController.triggerUpdate`, `[${this.categoryId}]`);
        if (this.updateCallback) {
            this.updateCallback();
        }
    }
    /**
     * 创建组件控制器
     * @param componentId 组件 ID
     * @returns 组件控制器
     */
    createController(componentId) {
        FXLogger_1.default.info(`FXViewCategoryController.createController`, `[${this.categoryId}]`, componentId);
        // ✅ 修复：不在闭包中捕获 componentItem，每次都从 Map 获取最新引用
        return {
            show: () => {
                this.show(componentId);
            },
            hide: () => {
                this.hide(componentId);
            },
            remove: () => {
                this.remove(componentId);
            },
            update: (component) => {
                this.update(componentId, component);
            },
            getFxViewId: () => this.fxViewId,
            getCategoryId: () => this.categoryId,
            getComponentId: () => componentId,
            getComponent: () => {
                var _a;
                // ✅ 每次都从 Map 获取最新的组件引用
                return (_a = this.componentMap.get(componentId)) === null || _a === void 0 ? void 0 : _a.component;
            },
            isVisible: () => {
                return this.isVisible(componentId);
            },
            exists: () => {
                return this.hasComponent(componentId);
            },
        };
    }
    /**
     * 自动生成 componentId
     * @returns 生成的 componentId
     */
    autoComponentId() {
        return `component_${Date.now()}_${Math.random()
            .toString(36)
            .substring(2, 9)}`;
    }
}
exports.FXCategoryController = FXCategoryController;
