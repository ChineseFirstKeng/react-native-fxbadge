/**
 * 通用的优先级队列 - 支持泛型存储，可切换大顶堆/小顶堆模式
 * 支持优先级相同时的排序策略：先入先出(FIFO)或后入先出(LIFO)
 */
export enum HeapType {
  MAX_HEAP = "max", // 大顶堆：优先级高的在前
  MIN_HEAP = "min", // 小顶堆：优先级低的在前
}

export enum PriorityOrder {
  FIFO = "fifo", // 先入先出：优先级相同时，先入队的在前
  LIFO = "lifo", // 后入先出：优先级相同时，后入队的在前
}

export class PriorityQueue<T> {
  private items: Array<{ item: T; priority: number; timestamp: number }> = [];
  private heapType: HeapType;
  private priorityOrder: PriorityOrder;

  constructor(
    heapType: HeapType = HeapType.MAX_HEAP,
    priorityOrder: PriorityOrder = PriorityOrder.FIFO,
  ) {
    this.heapType = heapType;
    this.priorityOrder = priorityOrder;
  }

  /**
   * 设置堆类型（可选参数）
   */
  setHeapType(heapType?: HeapType): void {
    if (heapType !== undefined && this.heapType !== heapType) {
      this.heapType = heapType;
      this.resort();
    }
  }

  /**
   * 获取当前堆类型
   */
  getHeapType(): HeapType {
    return this.heapType;
  }

  /**
   * 设置优先级相同时的排序策略（可选参数）
   */
  setPriorityOrder(order?: PriorityOrder): void {
    if (order !== undefined && this.priorityOrder !== order) {
      this.priorityOrder = order;
      this.resort();
    }
  }

  /**
   * 获取当前优先级相同时的排序策略
   */
  getPriorityOrder(): PriorityOrder {
    return this.priorityOrder;
  }

  /**
   * 入队 - 按当前堆类型和排序策略排序
   */
  enqueue(item: T, priority: number = 0, timestamp?: number): void {
    const newTimestamp = timestamp !== undefined ? timestamp : Date.now();

    // 如果 item 已存在，移除旧项
    const existingIndex = this.items.findIndex((entry) => entry.item === item);
    if (existingIndex !== -1) {
      this.items.splice(existingIndex, 1);
    }

    const newItem = {
      item,
      priority,
      timestamp: newTimestamp,
    };

    // 根据堆类型和排序策略找到插入位置
    let insertIndex = this.items.length;
    for (let i = 0; i < this.items.length; i++) {
      if (this.shouldInsertBefore(newItem, this.items[i])) {
        insertIndex = i;
        break;
      }
    }

    this.items.splice(insertIndex, 0, newItem);
  }

  /**
   * 批量入队（可选参数）
   */
  enqueueMultiple(items: T[], priority: number = 0): void {
    items.forEach((item) => this.enqueue(item, priority));
  }

  /**
   * 出队 - 返回队首元素（最高或最低优先级）
   */
  dequeue(): T | null {
    if (this.isEmpty()) {
      return null;
    }
    return this.items.shift()!.item;
  }

  /**
   * 批量出队（可选参数）
   */
  dequeueMultiple(count?: number): T[] {
    if (count === undefined) {
      count = this.items.length;
    }

    const result: T[] = [];
    for (let i = 0; i < count && !this.isEmpty(); i++) {
      const item = this.dequeue();
      if (item !== null) {
        result.push(item);
      }
    }
    return result;
  }

  /**
   * 查看队首元素（不移除）
   */
  peek(): T | null {
    if (this.isEmpty()) {
      return null;
    }
    return this.items[0].item;
  }

  /**
   * 查看队首元素的优先级
   */
  peekPriority(): number | null {
    if (this.isEmpty()) {
      return null;
    }
    return this.items[0].priority;
  }

  /**
   * 查看前N个元素（可选参数）
   */
  peekMultiple(count?: number): T[] {
    if (count === undefined) {
      count = this.items.length;
    }

    return this.items
      .slice(0, Math.min(count, this.items.length))
      .map((entry) => entry.item);
  }

  /**
   * 队列是否为空
   */
  isEmpty(): boolean {
    return this.items.length === 0;
  }

  /**
   * 队列大小
   */
  size(): number {
    return this.items.length;
  }

  /**
   * 清空队列
   */
  clear(): void {
    this.items = [];
  }

  /**
   * 获取所有元素（按当前堆类型排序）
   */
  getAll(): T[] {
    return this.items.map((entry) => entry.item);
  }

  /**
   * 获取所有元素及其优先级
   */
  getAllWithPriority(): Array<{ item: T; priority: number }> {
    return this.items.map(({ item, priority }) => ({ item, priority }));
  }

  /**
   * 获取所有元素及其详细信息
   */
  getAllWithDetails(): Array<{ item: T; priority: number; timestamp: number }> {
    return [...this.items];
  }

  /**
   * 获取指定索引的元素（可选参数）
   */
  getAt(index: number = 0): T | null {
    if (index < 0 || index >= this.items.length) {
      return null;
    }
    return this.items[index].item;
  }

  /**
   * 获取指定范��的元素（可选参数）
   */
  getRange(start: number = 0, end?: number): T[] {
    if (end === undefined) {
      end = this.items.length;
    }

    return this.items.slice(start, end).map((entry) => entry.item);
  }

  /**
   * 移除指定元素
   */
  remove(item: T): boolean {
    const index = this.items.findIndex((entry) => entry.item === item);
    if (index >= 0) {
      this.items.splice(index, 1);
      return true;
    }
    return false;
  }

  /**
   * 移除指定索引的元素（可选参数）
   */
  removeAt(index: number = 0): T | null {
    if (index < 0 || index >= this.items.length) {
      return null;
    }
    const [removed] = this.items.splice(index, 1);
    return removed.item;
  }

  /**
   * 更新元素的优先级
   */
  updatePriority(item: T, newPriority: number = 0): boolean {
    const index = this.items.findIndex((entry) => entry.item === item);
    if (index >= 0) {
      // 先移除，再重新插入
      this.items.splice(index, 1);
      this.enqueue(item, newPriority);
      return true;
    }
    return false;
  }

  /**
   * 查找指定元素
   */
  find(predicate: (item: T) => boolean): T | null {
    const entry = this.items.find((entry) => predicate(entry.item));
    return entry ? entry.item : null;
  }

  /**
   * 查找所有符合条件的元素
   */
  findAll(predicate: (item: T) => boolean): T[] {
    return this.items
      .filter((entry) => predicate(entry.item))
      .map((entry) => entry.item);
  }

  /**
   * 过滤元素
   */
  filter(predicate: (item: T) => boolean): T[] {
    return this.findAll(predicate);
  }

  /**
   * 遍历元素
   */
  forEach(callback: (item: T, priority: number, index: number) => void): void {
    this.items.forEach((entry, index) => {
      callback(entry.item, entry.priority, index);
    });
  }

  /**
   * 映射元素
   */
  map<U>(callback: (item: T, priority: number, index: number) => U): U[] {
    return this.items.map((entry, index) =>
      callback(entry.item, entry.priority, index),
    );
  }

  /**
   * 判断是否应该插入到指定元素之前
   */
  private shouldInsertBefore(
    newItem: { item: T; priority: number; timestamp: number },
    existingItem: { item: T; priority: number; timestamp: number },
  ): boolean {
    // 首先比较优先级
    if (this.heapType === HeapType.MAX_HEAP) {
      // 大顶堆：优先级高的在前
      if (newItem.priority > existingItem.priority) return true;
      if (newItem.priority < existingItem.priority) return false;
    } else {
      // 小顶堆：优先级低的在前
      if (newItem.priority < existingItem.priority) return true;
      if (newItem.priority > existingItem.priority) return false;
    }

    // 优先级相同时，根据排序策略决定
    if (this.priorityOrder === PriorityOrder.FIFO) {
      // 先入先出：时间戳小的在前（先入队的在前）
      return newItem.timestamp < existingItem.timestamp;
    } else {
      // 后入先出：时间戳大的在前（后入队的在前）
      return newItem.timestamp > existingItem.timestamp;
    }
  }

  /**
   * 重新排序所有元素
   */
  private resort(): void {
    const items = [...this.items];
    this.items = [];

    // 按照新的堆类型和排序策略重新入队，保留原有时间戳
    items.forEach((entry) => {
      this.enqueue(entry.item, entry.priority, entry.timestamp);
    });
  }

  /**
   * 转换为数组
   */
  toArray(): T[] {
    return this.getAll();
  }

  /**
   * 转换为JSON字符串
   */
  toJSON(): string {
    return JSON.stringify(this.getAllWithDetails());
  }

  /**
   * 克隆队列
   */
  clone(): PriorityQueue<T> {
    const newQueue = new PriorityQueue<T>(this.heapType, this.priorityOrder);
    this.items.forEach((entry) => {
      newQueue.enqueue(entry.item, entry.priority, entry.timestamp);
    });
    return newQueue;
  }
}
