/**
 * 通用的优先级队列 - 支持泛型存储，可切换大顶堆/小顶堆模式
 * 支持优先级相同时的排序策略：先入先出(FIFO)或后入先出(LIFO)
 */
export declare enum HeapType {
    MAX_HEAP = "max",// 大顶堆：优先级高的在前
    MIN_HEAP = "min"
}
export declare enum PriorityOrder {
    FIFO = "fifo",// 先入先出：优先级相同时，先入队的在前
    LIFO = "lifo"
}
export declare class PriorityQueue<T> {
    private items;
    private heapType;
    private priorityOrder;
    constructor(heapType?: HeapType, priorityOrder?: PriorityOrder);
    /**
     * 设置堆类型（可选参数）
     */
    setHeapType(heapType?: HeapType): void;
    /**
     * 获取当前堆类型
     */
    getHeapType(): HeapType;
    /**
     * 设置优先级相同时的排序策略（可选参数）
     */
    setPriorityOrder(order?: PriorityOrder): void;
    /**
     * 获取当前优先级相同时的排序策略
     */
    getPriorityOrder(): PriorityOrder;
    /**
     * 入队 - 按当前堆类型和排序策略排序
     */
    enqueue(item: T, priority?: number, timestamp?: number): void;
    /**
     * 批量入队（可选参数）
     */
    enqueueMultiple(items: T[], priority?: number): void;
    /**
     * 出队 - 返回队首元素（最高或最低优先级）
     */
    dequeue(): T | null;
    /**
     * 批量出队（可选参数）
     */
    dequeueMultiple(count?: number): T[];
    /**
     * 查看队首元素（不移除）
     */
    peek(): T | null;
    /**
     * 查看队首元素的优先级
     */
    peekPriority(): number | null;
    /**
     * 查看前N个元素（可选参数）
     */
    peekMultiple(count?: number): T[];
    /**
     * 队列是否为空
     */
    isEmpty(): boolean;
    /**
     * 队列大小
     */
    size(): number;
    /**
     * 清空队列
     */
    clear(): void;
    /**
     * 获取所有元素（按当前堆类型排序）
     */
    getAll(): T[];
    /**
     * 获取所有元素及其优先级
     */
    getAllWithPriority(): Array<{
        item: T;
        priority: number;
    }>;
    /**
     * 获取所有元素及其详细信息
     */
    getAllWithDetails(): Array<{
        item: T;
        priority: number;
        timestamp: number;
    }>;
    /**
     * 获取指定索引的元素（可选参数）
     */
    getAt(index?: number): T | null;
    /**
     * 获取指定范��的元素（可选参数）
     */
    getRange(start?: number, end?: number): T[];
    /**
     * 移除指定元素
     */
    remove(item: T): boolean;
    /**
     * 移除指定索引的元素（可选参数）
     */
    removeAt(index?: number): T | null;
    /**
     * 更新元素的优先级
     */
    updatePriority(item: T, newPriority?: number): boolean;
    /**
     * 查找指定元素
     */
    find(predicate: (item: T) => boolean): T | null;
    /**
     * 查找所有符合条件的元素
     */
    findAll(predicate: (item: T) => boolean): T[];
    /**
     * 过滤元素
     */
    filter(predicate: (item: T) => boolean): T[];
    /**
     * 遍历元素
     */
    forEach(callback: (item: T, priority: number, index: number) => void): void;
    /**
     * 映射元素
     */
    map<U>(callback: (item: T, priority: number, index: number) => U): U[];
    /**
     * 判断是否应该插入到指定元素之前
     */
    private shouldInsertBefore;
    /**
     * 重新排序所有元素
     */
    private resort;
    /**
     * 转换为数组
     */
    toArray(): T[];
    /**
     * 转换为JSON字符串
     */
    toJSON(): string;
    /**
     * 克隆队列
     */
    clone(): PriorityQueue<T>;
}
//# sourceMappingURL=PriorityQueue.d.ts.map