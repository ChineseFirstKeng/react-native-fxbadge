"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PriorityQueue = exports.PriorityOrder = exports.HeapType = void 0;
/**
 * 通用的优先级队列 - 支持泛型存储，可切换大顶堆/小顶堆模式
 * 支持优先级相同时的排序策略：先入先出(FIFO)或后入先出(LIFO)
 */
var HeapType;
(function (HeapType) {
    HeapType["MAX_HEAP"] = "max";
    HeapType["MIN_HEAP"] = "min";
})(HeapType || (exports.HeapType = HeapType = {}));
var PriorityOrder;
(function (PriorityOrder) {
    PriorityOrder["FIFO"] = "fifo";
    PriorityOrder["LIFO"] = "lifo";
})(PriorityOrder || (exports.PriorityOrder = PriorityOrder = {}));
class PriorityQueue {
    constructor(heapType = HeapType.MAX_HEAP, priorityOrder = PriorityOrder.FIFO) {
        this.items = [];
        this.heapType = heapType;
        this.priorityOrder = priorityOrder;
    }
    /**
     * 设置堆类型（可选参数）
     */
    setHeapType(heapType) {
        if (heapType !== undefined && this.heapType !== heapType) {
            this.heapType = heapType;
            this.resort();
        }
    }
    /**
     * 获取当前堆类型
     */
    getHeapType() {
        return this.heapType;
    }
    /**
     * 设置优先级相同时的排序策略（可选参数）
     */
    setPriorityOrder(order) {
        if (order !== undefined && this.priorityOrder !== order) {
            this.priorityOrder = order;
            this.resort();
        }
    }
    /**
     * 获取当前优先级相同时的排序策略
     */
    getPriorityOrder() {
        return this.priorityOrder;
    }
    /**
     * 入队 - 按当前堆类型和排序策略排序
     */
    enqueue(item, priority = 0, timestamp) {
        const newTimestamp = timestamp !== undefined ? timestamp : Date.now();
        // 如果 item 已存在，移除旧项
        const existingIndex = this.items.findIndex((entry) => entry.item === item);
        if (existingIndex !== -1) {
            this.items.splice(existingIndex, 1);
        }
        const newItem = {
            item,
            priority,
            timestamp: newTimestamp,
        };
        // 根据堆类型和排序策略找到插入位置
        let insertIndex = this.items.length;
        for (let i = 0; i < this.items.length; i++) {
            if (this.shouldInsertBefore(newItem, this.items[i])) {
                insertIndex = i;
                break;
            }
        }
        this.items.splice(insertIndex, 0, newItem);
    }
    /**
     * 批量入队（可选参数）
     */
    enqueueMultiple(items, priority = 0) {
        items.forEach((item) => this.enqueue(item, priority));
    }
    /**
     * 出队 - 返回队首元素（最高或最低优先级）
     */
    dequeue() {
        if (this.isEmpty()) {
            return null;
        }
        return this.items.shift().item;
    }
    /**
     * 批量出队（可选参数）
     */
    dequeueMultiple(count) {
        if (count === undefined) {
            count = this.items.length;
        }
        const result = [];
        for (let i = 0; i < count && !this.isEmpty(); i++) {
            const item = this.dequeue();
            if (item !== null) {
                result.push(item);
            }
        }
        return result;
    }
    /**
     * 查看队首元素（不移除）
     */
    peek() {
        if (this.isEmpty()) {
            return null;
        }
        return this.items[0].item;
    }
    /**
     * 查看队首元素的优先级
     */
    peekPriority() {
        if (this.isEmpty()) {
            return null;
        }
        return this.items[0].priority;
    }
    /**
     * 查看前N个元素（可选参数）
     */
    peekMultiple(count) {
        if (count === undefined) {
            count = this.items.length;
        }
        return this.items
            .slice(0, Math.min(count, this.items.length))
            .map((entry) => entry.item);
    }
    /**
     * 队列是否为空
     */
    isEmpty() {
        return this.items.length === 0;
    }
    /**
     * 队列大小
     */
    size() {
        return this.items.length;
    }
    /**
     * 清空队列
     */
    clear() {
        this.items = [];
    }
    /**
     * 获取所有元素（按当前堆类型排序）
     */
    getAll() {
        return this.items.map((entry) => entry.item);
    }
    /**
     * 获取所有元素及其优先级
     */
    getAllWithPriority() {
        return this.items.map(({ item, priority }) => ({ item, priority }));
    }
    /**
     * 获取所有元素及其详细信息
     */
    getAllWithDetails() {
        return [...this.items];
    }
    /**
     * 获取指定索引的元素（可选参数）
     */
    getAt(index = 0) {
        if (index < 0 || index >= this.items.length) {
            return null;
        }
        return this.items[index].item;
    }
    /**
     * 获取指定范��的元素（可选参数）
     */
    getRange(start = 0, end) {
        if (end === undefined) {
            end = this.items.length;
        }
        return this.items.slice(start, end).map((entry) => entry.item);
    }
    /**
     * 移除指定元素
     */
    remove(item) {
        const index = this.items.findIndex((entry) => entry.item === item);
        if (index >= 0) {
            this.items.splice(index, 1);
            return true;
        }
        return false;
    }
    /**
     * 移除指定索引的元素（可选参数）
     */
    removeAt(index = 0) {
        if (index < 0 || index >= this.items.length) {
            return null;
        }
        const [removed] = this.items.splice(index, 1);
        return removed.item;
    }
    /**
     * 更新元素的优先级
     */
    updatePriority(item, newPriority = 0) {
        const index = this.items.findIndex((entry) => entry.item === item);
        if (index >= 0) {
            // 先移除，再重新插入
            this.items.splice(index, 1);
            this.enqueue(item, newPriority);
            return true;
        }
        return false;
    }
    /**
     * 查找指定元素
     */
    find(predicate) {
        const entry = this.items.find((entry) => predicate(entry.item));
        return entry ? entry.item : null;
    }
    /**
     * 查找所有符合条件的元素
     */
    findAll(predicate) {
        return this.items
            .filter((entry) => predicate(entry.item))
            .map((entry) => entry.item);
    }
    /**
     * 过滤元素
     */
    filter(predicate) {
        return this.findAll(predicate);
    }
    /**
     * 遍历元素
     */
    forEach(callback) {
        this.items.forEach((entry, index) => {
            callback(entry.item, entry.priority, index);
        });
    }
    /**
     * 映射元素
     */
    map(callback) {
        return this.items.map((entry, index) => callback(entry.item, entry.priority, index));
    }
    /**
     * 判断是否应该插入到指定元素之前
     */
    shouldInsertBefore(newItem, existingItem) {
        // 首先比较优先级
        if (this.heapType === HeapType.MAX_HEAP) {
            // 大顶堆：优先级高的在前
            if (newItem.priority > existingItem.priority)
                return true;
            if (newItem.priority < existingItem.priority)
                return false;
        }
        else {
            // 小顶堆：优先级低的在前
            if (newItem.priority < existingItem.priority)
                return true;
            if (newItem.priority > existingItem.priority)
                return false;
        }
        // 优先级相同时，根据排序策略决定
        if (this.priorityOrder === PriorityOrder.FIFO) {
            // 先入先出：时间戳小的在前（先入队的在前）
            return newItem.timestamp < existingItem.timestamp;
        }
        else {
            // 后入先出：时间戳大的在前（后入队的在前）
            return newItem.timestamp > existingItem.timestamp;
        }
    }
    /**
     * 重新排序所有元素
     */
    resort() {
        const items = [...this.items];
        this.items = [];
        // 按照新的堆类型和排序策略重新入队，保留原有时间戳
        items.forEach((entry) => {
            this.enqueue(entry.item, entry.priority, entry.timestamp);
        });
    }
    /**
     * 转换为数组
     */
    toArray() {
        return this.getAll();
    }
    /**
     * 转换为JSON字符串
     */
    toJSON() {
        return JSON.stringify(this.getAllWithDetails());
    }
    /**
     * 克隆队列
     */
    clone() {
        const newQueue = new PriorityQueue(this.heapType, this.priorityOrder);
        this.items.forEach((entry) => {
            newQueue.enqueue(entry.item, entry.priority, entry.timestamp);
        });
        return newQueue;
    }
}
exports.PriorityQueue = PriorityQueue;
